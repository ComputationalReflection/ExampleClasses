var rules = [{"rule_id":"CMU-SEC56","rule_syntactic_construct":"ATTR_DEF","rule_name":"Do Not Serialize Direct Handles to System Resources","rule_category":"Reliability","rule_description":"We detect types implementing java.io.Serializable and defining any non-transient field derived from system resources such as java.io.File, org.omg.CosNaming.NamingContext, org.om.CORBA.DomainManager, etc. This rule encourages programmers to make the detected fields transient."},{"rule_id":"CMU-OBJ54","rule_syntactic_construct":"ASSIGNMENT","rule_name":"Do Not Attempt to Help the Garbage Collector by Setting Local Reference Variables to Null","rule_category":"Programmer Misconceptions","rule_description":"This rule detects the assignment of null to local variables that are no longer used."},{"rule_id":"CMU-OBJ50","rule_syntactic_construct":"VARIABLE_DEF","rule_name":"Never Confuse the Inmutability of a Reference with that of the Referenced Object","rule_category":"Programmer Misconceptions","rule_description":"It is checked that the states of objects pointed by final references are not mutated. We exclude assignments to fields inside constructors (or methods only called by constructors) since we understood them as initialization, not mutations."},{"rule_id":"CMU-NUM50","rule_syntactic_construct":"VARIABLE_DEF","rule_name":"Convert Integers to Floating Point for Floating-Point Operations","rule_category":"Program Understandability","rule_description":"The rule detects division expressions where the two operands are/promote to integers, and the result is assigned to a float or double. It is recommended to include a double literal (1.0) as an operand (in case the programmer wants to enforce a double division) or to change the type of the variable to integer (if an integer result is expected)."},{"rule_id":"CMU-MET55","rule_syntactic_construct":"RETURN_STATEMENT","rule_name":"Return an Empty Array or Collection Instead of a Null Value for Methods that Return an Array or Collection","rule_category":"Reliability","rule_description":"This rule detects statements returning the null literal in methods whose return type is an array or implements the java.util.Collection interface and encourages the programmer to use and empty collection or array instead."},{"rule_id":"CMU-MET53","rule_syntactic_construct":"METHOD_DEF","rule_name":"Ensure that the clone() Method Calls super.clone()","rule_category":"Program Understandability","rule_description":"This rule detects implementations of the clone method that do not call (directly or indirectly) super.clone() and encourages the programmer to include such call."},{"rule_id":"CMU-MET52","rule_syntactic_construct":"METHOD_INVOCATION","rule_name":"Do Not Use the clone() Method to Copy Untrusted Method Parameters","rule_category":"Security","rule_description":"Inappropriate implementations of the clone method return objects that bypass validation and security checks. That vulnerable implementation of clone is commonly hidden by the attacker in derived classes of the cloned parameter. Thus, the rule checks when clone is invoked against a parameter in a public method of a public class, and the type of the parameter is not final (overridable)."},{"rule_id":"CMU-MET50","rule_syntactic_construct":"METHOD_DEF","rule_name":"Avoid Ambiguous or Confusing Uses of Overloading","rule_category":"Program Understandability","rule_description":"This rule detects classes with overloaded methods with a) the same parameter types in a different order; or b) four or more parameters in different implementations."},{"rule_id":"CMU-ERR54","rule_syntactic_construct":"LOCAL_VAR_DEF","rule_name":"Use a Try-With-Resources Statement to Safely Handle Closeable Resources","rule_category":"Reliability","rule_description":"We detect when a local variable that implements java.lang.AutoCloseable is not initialized in a try-with-resources statement, and the code may throw an exception before calling close. In that case, a try-with-resources statement is advised to the programmer."},{"rule_id":"CMU-DCL60","rule_syntactic_construct":"PACKAGE","rule_name":"Avoid Cyclic Dependencies Between Packages","rule_category":"Bad Practice","rule_description":"This rule detects cyclic dependencies between packages and encourages the programmer to undo them."},{"rule_id":"CMU-DCL56","rule_syntactic_construct":"METHOD_INVOCATION","rule_name":"Do Not Attach Significance to the Ordinal Associated with an Enum","rule_category":"Bad Practice","rule_description":"If the ordinal method of some java.lang.Enum is invoked, this rule encourages the programmer to add a new integer field and access it instead."},{"rule_id":"CMU-DCL53","rule_syntactic_construct":"ATTR_DEF","rule_name":"Minimize the Scope of the Variables - II(Fields)","rule_category":"Bad Practice","rule_description":"We search for fields that are unconditionally assigned before their usage, for all the methods. The rule encourages the programmer to use local variables instead."},{"rule_id":"BLOCH-9.63","rule_syntactic_construct":"CALL","rule_name":"Include failure-capture information in detail messages","rule_category":"Reliability","rule_description":"This rule detects Exception subtype classes that do not provide enough parameters to encapsulate all the failure-capture information. To do so, the rule detects constructor calls from these classes, where a string is passed as argument concatenating different types of data (**Scenario 1**). \nMoreover, this rule also detects constructor calls from Exception subtype classes where a string is passed as argument concatenating different types of data, but whose classes define a constructor with enough parameters to store the failure-capture information without any concatenation (**Scenario 2**)."},{"rule_id":"BLOCH-8.45","rule_syntactic_construct":"LOCAL_VAR_DEF","rule_name":"Minimize the scope of local variables","rule_category":"Bad Practice","rule_description":"This rule detects both initialized and non-initialized local variable declarations which are not used in the following statement of the program. The rule makes the recommendation of moving these declarations before the statements in which are used for the first time. In case these first uses are located inside a try-catch block or other inner scopes (for instance, inisde if or for blocks), the declaration should be moved before the statement in which the scope changes (unless this variable is only used inside this scope)."},{"rule_id":"BLOCH-7.40.2","rule_syntactic_construct":"PARAMETER_DEF","rule_name":"For parameter types, favor interfaces over classes","rule_category":"Bad Practice","rule_description":"This rule detects public method definitions in which the type of one of its parameters implements a interface that can be interchanged for the type. This interface should define all the methods and fields used in the body of the method. The change should not affect the rest of the implementation (those regarding lvalue types in assignments and method invocations where the parameter is passed as argument), but may generate small errors that could be solved with easy fixes."},{"rule_id":"BLOCH-6.36","rule_syntactic_construct":"METHOD_DEF","rule_name":"Consistently use the Override annotation","rule_category":"Bad Practice","rule_description":"This rule detects methods, defined in one of its supertypes, which have the same name and parameter types. If this method has no Override annotation, a warning is prompted."},{"rule_id":"BLOCH-4.13.1","rule_syntactic_construct":"CLASS_DEF","rule_name":"Minimize the accessibility of classes","rule_category":"Bad Practice","rule_description":"This rule detects public classes that are only used inside its own package in order to change its visibility to \"package-protected\" so it cannot be visible for the client (**Scenario 1**).\nMoreover, this rule also detects public and package-protected classes that are only used inside one class in order to tranform the first class into a inner one inside the class where it is being used, changing its visibility to private (**Scenario 2**)."},{"rule_id":"BLOCH-3.10S","rule_syntactic_construct":"TYPE_DEFINITION","rule_name":"Provide public access for every field used in the toString method","rule_category":"Bad Practice","rule_description":"This rule detects classes that do not provide public getters to access fields which are used in expressions returned by the toString method."},{"rule_id":"BLOCH-3.10","rule_syntactic_construct":"TYPE_DEFINITION","rule_name":"Always override toString","rule_category":"Reliability","rule_description":"This rule detects classes not implementing/redefining the toString method when this method is being invoked somewhere in the code."},{"rule_id":"BLOCH-2.4","rule_syntactic_construct":"TYPE_DEFINITION","rule_name":"Enforce noninstanciability with a private constructor","rule_category":"Bad Practice","rule_description":"This rule detects static classes (with only static members) without a private constructor in order to enforce noninstanciability by implementing this missing private constructor in those classes."}];